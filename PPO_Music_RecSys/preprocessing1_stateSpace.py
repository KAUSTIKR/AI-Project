# -*- coding: utf-8 -*-
"""stateSpace_autoencoder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EklrhfMcszdx24ac12G6RxnihotqX7AW
"""
# Using an autoencoder neural network, we generate the state space for our reinforcement learning problem.
# Each track is represented by a 5-D latent vector, which serves as its state.
# This 5D vector captures the underlying features of the track and defines its position in the state space.


import pandas as pd
import torch.nn.functional as F
import matplotlib.pyplot as plt
import seaborn as sns
import torch
from torch.utils.data import DataLoader, TensorDataset
import torch.nn as nn
from sklearn.preprocessing import MinMaxScaler

df = pd.read_csv("filtered_artist_data.csv")

columns_to_keep = [
    'id', 'danceability', 'energy', 'key', 'loudness', 'mode',
    'speechiness', 'acousticness', 'instrumentalness', 'liveness',
    'valence', 'tempo']
df_filtered = df[columns_to_keep]
print(df_filtered.head())

print(df_filtered.isnull().sum())
df_filtered = df_filtered.dropna()

from sklearn.preprocessing import MinMaxScaler
features = df_filtered.drop(columns=['id'])
scaler = MinMaxScaler()
features_scaled = scaler.fit_transform(features)
df_normalized = pd.DataFrame(features_scaled, columns=features.columns)
df_normalized['id'] = df_filtered['id'].values
df_normalized = df_normalized[['id'] + [col for col in df_normalized.columns if col != 'id']]
print(df_normalized.head())

df_normalized.to_csv("preprocessed_audio_features.csv", index=False)

features_only = df_normalized.drop(columns=['id'])
cov_matrix = features_only.cov()
print(cov_matrix)

plt.figure(figsize=(10, 8))
sns.heatmap(cov_matrix, annot=True, fmt=".2f", cmap="coolwarm")
plt.title("Covariance Matrix of Audio Features")
plt.show()

correlation_matrix = features_only.corr()
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap="coolwarm")
plt.title("Correlation Matrix")
plt.show()

df = pd.read_csv("preprocessed_audio_features.csv")
selected_features = [
    'id', 'danceability', 'key', 'mode',
    'speechiness', 'liveness', 'valence', 'tempo'
]

df_filtered = df[selected_features]
print(df_filtered.head())

track_ids = df_filtered['id']
X = df_filtered.drop(columns=['id']).values

scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
print(X_scaled)

X_tensor = torch.tensor(X_scaled, dtype=torch.float32)
dataset = TensorDataset(X_tensor)
loader = DataLoader(dataset, batch_size=32, shuffle=True)

# VAE neural network Encoder and decoder with help of KL divergence
class VAE(nn.Module):
    def __init__(self, input_dim=7, latent_dim=5):
        super(VAE, self).__init__()
        self.fc1 = nn.Linear(input_dim, 32)
        self.fc21 = nn.Linear(32, latent_dim)
        self.fc22 = nn.Linear(32, latent_dim)
        self.fc3 = nn.Linear(latent_dim, 32)
        self.fc4 = nn.Linear(32, input_dim)

    def encode(self, x):
        h1 = F.relu(self.fc1(x))
        mu = self.fc21(h1)
        logvar = self.fc22(h1)
        return mu, logvar

    def reparameterize(self, mu, logvar):
        std = torch.exp(0.5 * logvar)
        eps = torch.randn_like(std)
        return mu + eps * std

    def decode(self, z):
        h3 = F.relu(self.fc3(z))
        return self.fc4(h3)

    def forward(self, x):
        mu, logvar = self.encode(x)
        z = self.reparameterize(mu, logvar)
        return self.decode(z), mu, logvar
def vae_loss(recon_x, x, mu, logvar):
    recon_loss = F.mse_loss(recon_x, x, reduction='mean')
    kl_div = -0.5 * torch.mean(1 + logvar - mu.pow(2) - logvar.exp())
    return recon_loss + kl_div

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = VAE(input_dim=7, latent_dim=5).to(device)
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
num_epochs = 500
for epoch in range(num_epochs):
    model.train()
    total_loss = 0
    for batch in loader:
        x_batch = batch[0].to(device)
        optimizer.zero_grad()
        recon_batch, mu, logvar = model(x_batch)
        loss = vae_loss(recon_batch, x_batch, mu, logvar)
        loss.backward()
        optimizer.step()
        total_loss += loss.item() * x_batch.size(0)
    avg_loss = total_loss / len(loader.dataset)
    if epoch % 10 == 0:
        print(f"Epoch {epoch}, Avg Loss: {avg_loss:.6f}")

model.eval()
all_latents = []
with torch.no_grad():
    for batch in loader:
        x_batch = batch[0].to(device)
        mu, logvar = model.encode(x_batch)
        z = model.reparameterize(mu, logvar)
        all_latents.append(z.cpu())
latent_vectors = torch.cat(all_latents, dim=0).numpy()

model.eval()
with torch.no_grad():
    x_batch = X_tensor.to(device)
    recon, _, _ = model(x_batch)
    mse = F.mse_loss(recon, x_batch, reduction='mean').item()
print(f"Reconstruction MSE: {mse:.6f}")

df_latents = pd.DataFrame(latent_vectors, columns=[f'latent_{i}' for i in range(latent_vectors.shape[1])])
df_latents['id'] = track_ids.values

df_latents = df_latents[['id'] + [col for col in df_latents.columns if col != 'id']]
# 5D latent vectors for each track
df_latents.to_csv("vae_latent_vectors.csv", index=False)